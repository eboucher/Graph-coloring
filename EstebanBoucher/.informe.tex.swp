\documentclass[11pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6.5in, 9in}]{geometry}
\usepackage{amsthm}

\theoremstyle{plain}
\setlength{\footskip}{90pt}
\begin{document}
\begin{titlepage}
	\centering

	\begin{figure}[htp]
	\centering
	\includegraphics[scale=.3]{/home/casa/logo-unc.jpeg}
	\end{figure}
	
	{\scshape\Large\textsc{Universidad Nacional de Córdoba} \par}
	\vspace{0.5cm}
	{\scshape\large FaMAF\par}
	\vspace{1.5cm}

	{\LARGE\bfseries Matemática Discreta II\par}
	\vspace{.7cm}
	{\Large Proyecto: Primera Parte\par}
	\vspace{3cm}
	{\Large\scshape{Esteban L. Boucher}\par}
	\vspace{.4cm}
	{\large\ttfamily eboucher7@gmail.com\par}
	\vspace{.4cm}
	{\large Septiembre 2016}
	\vfill
	Prof.~Daniel \textsc{Penazzi}

	\date{Septiembre, 2016}
\end{titlepage}

\renewcommand\refname{}

\renewcommand{\contentsname}{Índice general}

\tableofcontents
	
\newpage
\section{Introducción}

	\subsection{Motivación del proyecto}

 El problema de coloreo de grafos consiste en asignar colores a ciertos elementos de un grafo sujetos a ciertas restricciones.

 El problema de coloreo de vértices es el problema más común de coloreo de grafos. El problema es, dados m colores, encontrar una forma de colorear los vértices de un grafo de tal manera que no hayan dos vértices adyacentes utilizando el mismo color.
 
 El interés acerca de este problema se debe a su gran número de aplicaciones. Entre las más conocidas de coloreo de grafos se destacan\cite {1}:
 
\begin{itemize}

\item{\textbf{{{{Establecer horarios y cronogramas}}}}}

Supongamos que queremos hacer un cronograma de exámenes para un universidad. Listamos diferentes asignaturas y estudiantes matriculados en cada asignatura. Muchas asignaturas tendrán estudiantes en común. \emph{¿Cómo se puede organizar el cronograma de modo que no hayan dos exámenes con un estudiante en común estén programadas al mismo tiempo? ¿Cuántas ranuras de tiempo mínimo son necesarios para programar todos los exámenes?} Este problema se puede representar como un grafo en el que cada vértice es una asignatura y una arista entre dos vértices significa que hay un estudiante común. Así que este es un problema de coloreo de grafos, donde el número mínimo de intervalos de tiempo es igual al número cromático del grafo.

\item{\textbf{{{Asignación de frecuencias de radio móvil}}}}

Cuando las frecuencias se asignan a las torres, las frecuencias asignadas a todas las torres en el mismo lugar debe ser diferente. Cómo asignar frecuencias con esta restricción? Lo que se necesita un número mínimo de frecuencias? Este problema es también un ejemplo de problema de coloración gráfica donde cada torre representa un vértice y un borde entre dos torres representa que están en el rango de la otra.

\item{\textbf{{{Sudoku}}}}

Suduku es también una variación del problema de coloreo de grafos en el cual cada celda representa un vértice. Hay una arista entre dos vértices si están en la misma fila o la misma columna o del mismo bloque.

\item{\textbf{{{Asignación de registros}}}}

En optimización de compiladores, la asignación de registros es el proceso de asignar un gran número de variables del programa de destino a un número reducido de registros de la CPU. Este problema también un problema de coloreo de grafos.

\item{\textbf{{{Grafos bipartitos}}}}

Podemos comprobar si un grafo es bipartito o no coloreando el grafo utilizando dos colores. Si un grafo dado es 2-coloreable, entonces es bipartito, de lo contrario no lo es. 
 
\item{\textbf{{{Mapa de coloreo}}}}

Mapas gráficos donde dos ciudades adyacentes no pueden ser asignadas con el mismo color. Cuatro colores son suficientes para colorear cualquier mapa\cite {2}.

\end{itemize}
 
 El siguiente proyecto consiste en la resolución de ese problema.

	\subsection{Propósito y objetivos}

Actualmente no se conoce un algoritmo de tiempo polinomial que resuelva el problema de coloreo de grafos. Sin embargo, hay una cierta calidad mínima que se puede obtener. Supongamos que \emph{d} es el mayor grado de cualquier vértice en nuestro grafo. A medida que avanzamos en el coloreo, cuando coloreamos cualquier vértice particular \emph{v}, está unido a lo sumo con otros \emph{d} vértices, de los cuales algunos pueden ya estar coloreados. Luego, hay a lo sumo \emph{d} colores que hay que evitar usar. Usamos el color de menor número no prohibido. Esto significa que usamos colores numerados \emph{d}+1 o menor, dado que al menos uno de los colores 1, 2, ..., \emph{d}+1 NO está prohibido. De esta manera, nunca necesitamos usar ningún color de mayor número que \emph{d}+1. Esto nos da el siguiente teorema:
	
\newtheorem*{Teorema*}{Teorema (Coloreo Greedy)}

\begin{Teorema*}
Si d es el mayor de los grados de los vértices en
un grafo G, entonces G tiene una coloración adecuada con d + 1 colores o menos, por vía intranasal, el número cromático de G es como máximo d + 1.
\end{Teorema*}

 Esto nos da una cota superior del número cromático del grafo\cite {4}.\\

El objetivo de este proyecto consiste en cargar un grafo y dar un coloreo propio de sus vértices, corriendo repetidamente Greedy usando órdenes que cumplan con el enunciado mencionado anteriormente.

	\subsection{Restricciones}

\begin{itemize}

\item\textbf{{Tiempo}}

El programa debe ser razonablemente rápido. En particular, con todos los grafos de ejemplo probados por la cátedra, el programa debe terminar en menos de una hora. Algunos de esos grafos pueden llegar a tener cerca de 2 millones de vértices y 10 millones de aristas.

\item\textbf{{Memoria}}

El programa nunca debe usar másde 256 MB de memoria RAM.

\end{itemize}

\section{Formato del archivo de entrada}

El formato de entrada será una variación de DIMACS, un formato estandard para representar grafos.
La descripción oficial de DIMACS es como sigue:

1. Ninguna linea tiene mas de 80 caracteres.

2. Al principio hay cero o más líneas que empiezan con 'c' (sin las comillas), las cuales son líneas de comentario y son ignoradas.

3. Luego hay una linea de la forma:
p edge n m

donde n y m son dos enteros. n representa el número de vértices y m el número de lados.

4. Luego siguen m lineas todas comenzando con 'e' (sin las comillas) y dos enteros, representando un lado. Luego de esas m lineas se detiene la carga.

\newpage


\section{Estructura de la implementación}

En la Figura 1 se muestra un diagrama de la estructuración del programa.\\ 

\begin{figure}[htp]
\centering
\includegraphics[scale=0.65]{diagram.pdf}
{\caption{}}
\label{fig:1}
\end{figure}

	\subsection{Descripción de estructuras y variables}
	
		\subsubsection{\texttt{struct \_NimheSt\_t}}
	
Las estructura principal de este programa es \texttt{struct \_NimheSt\_t}, la cual contiene toda la información necesaria para correr el algoritmo de Greedy y obtener información necesaria para modificar el órden de los vértices acorde a las distintas funciones de ordenación.\\

\begin{itemize}
\item\textbf{{Información básica del grafo}}\\

 Esta estructura contiene la cantidad de vértices y lados del grafo cargado y la cantidad de colores que está usando en el momento para colorear los vértices que contiene.\\

\item\textbf{{Información de los vértices del grafo}}\\
 
 En esta implementación la información que define a los vértices está dispersada en distintos arreglos dentro de la estructura del grafo: un \texttt{name\_array} que contiene los nombres "reales" de los vértices, los cuales en esta implementación son enteros sin signo de 32 bits; un \texttt{color\_array} que guarda el coloreo actual de los vértices, un \texttt{degree\_array} para los grados de los vértices, un \texttt{RAR\_order\_array} para guardar el órden en el cual los vértices deben colorearse si se usa \texttt{ReordenAleatorioRestringido}. Los últimos datos acerca de los vértices son las listas de vecinos, estas están en \texttt{neighbors\_array}, un arreglo de vectores en los cuales se guardan los índices de los vecinos de un vértice\\

\item\textbf{{Información de órdenes de los vértices}}\\

Se utiliza principalmente un arreglo \texttt{order}, que se utiliza para dar el coloreo cuando se corre \emph{Greedy} sobre el grafo. Los arreglos \texttt{natural\_order} y \texttt{vertices\_with\_color} se utilizan para guardar el \emph{órden natural} y \emph{la cantidad de colores coloreados con el color con el que está coloreado el vértice en la i-ésima posición del arreglo}, respectivamente. Se asignan los valores de los últimos dos arreglos al arreglo \texttt{order} cuando se llama a la función de ordenación correspondiente. Más sobre las funciones de ordenación adelante.

\item\textbf{{Información de control}}\\

Se utiliza un arreglo de booleanos \texttt{used} para verificar si algún \emph{ítem} está siendo usado. Utilizo el término impreciso \emph{ítem} justamente porque la semántica de este arreglo cambia en distintos contextos. Esta es sin dudas una práctica que por motivos razonables no se promueve. 

Sin embargo para el propósito de este proyecto resulta ser beneficioso, dado que si no se contara con esta variable compartida: 

1. Las tres funciones que con esta implementación utilizan el arreglo compartido, deberían crear el arreglo por separado y alocar memoria para la cantidad de elementos necesarios, lo cual lentifica el programa ya que dichas funciones se ejecutan repetidas veces y en ocasiones requiriendo arreglos muy grandes.

2. Aumenta el tamaño máximo de memoria RAM residente ocupado por el programa en ejecución, dado que la memoria de los otros arreglos no se estaría liberando. Si así fuera, el código sería más complicado, y no resolvería el problema 1.

Esto se puede evitar con la variable compartida, dado que en los tres casos, el arreglo requerido es del mismo tamaño - igual a la cantidad de vértices del grafo - y el tipo de datos del arreglo en los tres casos es el mismo, de tipo booleano, más adelante se explicarán sus utilizaciones por separado.\\

Una característica que se mencionó sin ser explicada es la de guardar índices de vértices, en lugar de estructuras, punteros a estructuras \texttt{\_VerticeSt\_t} o los \emph{nombres reales} de los vértices vecinos. Esto se debe a la elección de diseño de esta implementación, el la cuál los vértices o sus nombres "reales" sólo sean de importancia durante la carga del grafo. Luego todas las operaciones se realizan en torno a los arreglos de ordenes o de la información de los vértices sin sus nombres. De esta manera los vértices son referidos luego de la carga directamente a través de sus indices o \emph{identificadores}. 

\end{itemize}
	
		\subsubsection{\texttt{struct \_VectorSt\_t}}

Estructura de datos para representar un arreglo dinámico. Se utiliza en la estructura del grafo para guardar los \emph{identificadores} de los vecinos de un vértice.

		\subsubsection{\texttt{struct \_QueueSt\_t}}

Estructura de datos que implementa una cola circular, dentro de sus miembros tiene un arreglo de \emph{elements} y dos enteros sin signo indicando los índices al primero y el último elemento de la cola.

		\subsubsection{\texttt{struct \_VerticeSt\_t}}

Estructura de datos no utilizada en la implementación del proyecto. Puede ser utilizada a través de las funciones de verificación de \texttt{struct VertexGraphData.\{c,h\}} con modificaciones en la función \texttt{main()}

		\subsection{Estructura general}

Debido al tamaño del proyecto, esta implentación se presenta en forma de distintos módulos, cada uno agrupando funcionalidades de manera que mantengan cierta independencia y faciliten la legibilidad. Notar sin embargo que los tipos abstractos de datos implementados no son respetados como tales dentro de las funciones de distintos archivos, dado que todos pertenecen a la misma API y por conveniencia se accede a los tipos abstractos de datos como a cualquier estructura.

			\subsubsection{\texttt{Types.h}}

			\subsubsection{\texttt{Cthulhu.\{c, h\}}}

			\subsubsection{\texttt{GraphLoad.\{c, h\}}}

			\subsubsection{\texttt{DataStructs.\{c, h\}}}

			\subsubsection{\texttt{SortFuncs.\{c, h\}}}

			\subsubsection{\texttt{ColorFuncs.\{c, h\}}}

		\subsection{Descripción de algoritmos}

\section{Indicaciones de error}

\section{Correctitud}

\section{Instrucciones de operación}

	\subsection{Mecanografiado de compilación}

Para compilar el proyecto:
\begin{quote}
\ttfamily{gcc -Wall -Wextra -O3 -std=c99 -Iapifiles dirmain/mainEBoucher.c apifiles/*.c -o EB}
\end{quote}

La ejecución se puede hacer de las dos siguientes maneras:
\begin{itemize}
\item{Carga mediante un archivo:
\begin{quote}
\ttfamily{./EB \textless [/ruta/al/archivo/nombre\_archivo]}
\end{quote}}

\item{Carga manual:
\begin{quote}
\ttfamily{./EB}
\end{quote}
 e ingresando el grafo manualmente.
}
\end{itemize}
	
	\subsection{Descripción de las pruebas}
	
Las pruebas consisten en el monitoreo de la ejecución del programa cuando se corre con un input dado y el control de los resultados de coloreo. Los estimadores de interés para el monitoreo de la ejecución son el tiempo transcurrido que tardó en ejecutarse, y el tamaño máximo del conjunto residente de memoria asignada.

En cuanto al control de los resultados de coloreo, basta con ejecutar la API junto con el \emph{mainEBoucher.c} provisto. Este imprime el coloreo obtenido de 10 iteraciones iniciales con \emph{órden aleatorio}, luego una iteración en \emph{Órden Welsh-Powell} y de no haberse encontrado el número cromático del grafo, corre \emph{Greedy} 1001 veces con los distintos órdenes implementados y luego imprime el mejor coloreo de esas corridas. También corre el algoritmo \emph{2-color} al principio para verificar si el grafo dado es 2-coloreable, y luego de las 11 primeras corridas, verifica si es 3-coloreable antes de correr \emph{Greedy} 1001 veces.
	
	\subsection{Mecanografiado de las pruebas}
	
Existe una gran variedad de herramientas para probar el tiempo y memoria consumidos por el programa. Menciono únicamente dos de ellas:\\

\textbf{1. Comando \emph{htop}}\\

 Utilizar \emph{htop} mientras se ejecuta el programa permite visualizar tanto la RAM (columna \emph{RES}) que está siendo usada por el proceso, y el tiempo (columna \emph{TIME+}).\\

\textbf{2. Comando \emph{time}}\\

El comando \emph{time} corre el programa y da un resúmen de la utilización de recursos.

Una manera de usar este comando puede ser:


\begin{quote}
\ttfamily{command time -v ./EB \textless [/ruta/al/archivo/nombre\_archivo]}
\end{quote}

Usar \emph{command} fuerza al shell a ejecutar \emph{time}, ignorando cualquier función del mismo nombre.\\

Opción \emph{ -v:} Usa el formato detallado, que muestra cada pieza de información disponible sobre el uso de recursos del programa con una descripción en inglés de su significado.

\section{Desafíos y elecciones de diseño}

	\subsection{Problema: vértices pueden ser cualquier u32}

	\subsection{Vecinos de un vértice}

	\subsection{Orden de los vértices}

	\subsection{Greedy()}

	\subsection{Funciones de ordenación}

		\subsubsection{Revierte()}

		\subsubsection{GrandeChico() y ChicoGrande()}
		
\section{Posibles mejoras}

\section{Comentarios}

\newpage
\section{Referencias}
\begin{thebibliography}{9}
\bibitem{1}
	http://www.geeksforgeeks.org/graph-coloring-applications/
\bibitem{2}
	https://en.wikipedia.org/wiki/Four\_color\_theorem
\bibitem{3}
	https://proofwiki.org/wiki/Definition:Proper\_Coloring
\bibitem{4}
 	http://web.math.princeton.edu/math\_alive/5/Notes2.pdf

\end{thebibliography}

\end{document}